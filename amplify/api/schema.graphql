# Filename: amplify/api/schema.graphql

# Input type for the payment request mutation
input PaymentRequestInput {
  amount: Float!
}

# Custom mutation to trigger the Lambda function
type Mutation {
  # Field name is 'requestPayment', takes 'input', returns String
  # @function directive links it to the Lambda function resource named 'sendPaymentRequestFn'
  # Ensure 'sendPaymentRequestFn' matches the name in backend.ts
  # @auth directive restricts access to logged-in users via Cognito User Pools
  requestPayment(input: PaymentRequestInput!): String
    @function(name: "sendPaymentRequestFn")
    @auth(rules: [{ allow: private, provider: userPools }])
}

# Enum used by LedgerEntry
enum LedgerEntryType {
  INVOICE
  CREDIT_NOTE
  INCREASE_ADJUSTMENT
  DECREASE_ADJUSTMENT
}

# LedgerEntry model definition using SDL directives
# @model generates DynamoDB table, CRUDL GraphQL operations
# @auth restricts access based on owner field
type LedgerEntry @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  type: LedgerEntryType!
  amount: Float!
  description: String
  createdAt: AWSDateTime! # Added standard timestamp
  updatedAt: AWSDateTime! # Added standard timestamp
  owner: String          # Field for owner authorization
}

# AccountStatus model definition using SDL directives
type AccountStatus @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  totalUnapprovedInvoiceValue: Float!
  currentAccountBalance: Float!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  owner: String
}

# Ensure standard Query types etc are added by @model, or define a basic one if needed
# type Query { getLedgerEntry(id: ID!): LedgerEntry @auth(rules: [{ allow: owner }]) }